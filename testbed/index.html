<!DOCTYPE html> 
<html lang="en"> 

<head> 
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1,user-scalable=no">


	<title>Teste RiscoJS V2</title> 
	<meta name="description" content="Teste RiscoJS V2<"> 
	<meta name="author" content="Rui Cavaco, CM-Porto, DMSI-SIG"> 

	<style>
		#PanelDiv {
			position: absolute;
			top: 0;
			left: 0;
			padding: 0;
			margin: 0;
			height: 100%;
			width: 100%;
			background: radial-gradient(#b6c3cc, #6aa5cc);			
		}

		#msgsdiv {
			font-family: sans-serif;
			position: absolute;
			top: 80px;
			left: 20%;
			background-color: rgba(255, 255, 255, 0.86);
			color: #000;
			padding: 12px 18px 12px 16px;
			width: 40%;
			max-width: 400px;
			min-width: 200px;
			font-size: 14px;
			z-index: 1000;
			text-align: left;
			box-shadow: 0 3px 14px rgba(0,0,0,0.6);
			overflow-y: auto;	
			margin: 0;	
		}		

		#msgsdiv img {
			float: left;
			padding-right: 20px;
		}

		#query_results {
			font-family: sans-serif;
			font-size: 12px;
		}

		#query_results p {
			margin: 0;

		}		

		#query_results p.hoverme:hover {
			font-weight: bold;
			background-color: rgb(126, 126, 126);
			color: white;
		}
		
		
	</style>
	
    <!-- 
	<link rel="stylesheet" href="css/mapctrls.css">
    <link rel="stylesheet" href="css/layout.css">

    <link rel="stylesheet" href="css/layout.css"/> -->

</head> 
<body> 

	<div id="PanelDiv">
	</div>

	<div id="msgsdiv" style="display: none;">
	</div>	

	<!-- Used ocasionally for debugging purposes -->
	<!-- <script src="js/riscojs_v2/polyfills.js"></script>	-->

	<script src="risco_text_config.js"></script>
	<script src="risco_basic_config.js"></script>
	<script src="colorramps.js"></script>
	<script src="risco_layers_config.js"></script>
	<script src="js/Messaging.js"></script>

	<script type="module">

		let RISCO_MAP_CFG = {
			"basic": RISCOJS_BASIC_CFG,
			"layers": RISCOJS_LAYERS_CFG,
			"text": RISCOJS_TEXT_CFG,
		}

		// check corners
		function checkPoints(p_mapctx) {

			let terrainPt = [];
			let canvasPt = [];
			let bounds = [];
			let cen = [];

			p_mapctx.transformmgr.getTerrainPt([0, 0], terrainPt);
			console.info("[TEST] terrainPt for canvas(0,0):", terrainPt);

			p_mapctx.renderingsmgr.getCanvasCenter(canvasPt);
			p_mapctx.transformmgr.getTerrainPt(canvasPt, terrainPt);
			console.info("[TEST] terrainPt for canvas center:", terrainPt);

			p_mapctx.renderingsmgr.getCanvasDims(canvasPt);
			p_mapctx.transformmgr.getTerrainPt(canvasPt, terrainPt);
			console.info("[TEST] canvas dims:", canvasPt);
			console.info("[TEST] terrainPt for canvas lower right:", terrainPt);

			p_mapctx.getMapBounds(bounds);
			console.info("[TEST] map bounds:", bounds);

			p_mapctx.getCenter(cen);
			console.info("[TEST] map center:", cen);


		}

		import {RiscoMapOverlay} from './js/riscojs_v2/main.mjs';
		import { ctrToolTip, CanvasLocLayerClass, GeoLocationMgr, MapCustomizations} from './js/riscojs_v2/default_customizations.mjs';
		import {GlobalConst} from './js/riscojs_v2/constants.js';
		import {LocQuery} from './js/cmp_customizations.mjs';

		let RiscoOVInst = new RiscoMapOverlay("PanelDiv");
		let mapctx = RiscoOVInst.newMapCtx(RISCO_MAP_CFG, "single", "canvas", true);

		mapctx.onAfterResize = function(p_mapctx) {
			checkPoints(p_mapctx);
		};

		MessagesController.check();

		
		const mc = new MapCustomizations(MessagesController);

		mapctx.setCustomizationObj(mc, function(p_this, p_mapctx) {
			
			const basic_config = p_mapctx.toolmgr.basic_config;
			let loc_layer = null;

			// Customizations changing controls or toolboxes go first
			// (limiting available space for other widgets)
			loc_layer = "LOCATIONS_LAYER";
			p_mapctx.tocmgr.addLayer("LOCATIONS_LAYER", {
				"strokeStyle": "red",
				"fillStyle": "none",
				"lineWidth": 3
			}, CanvasLocLayerClass);
								
			p_this.instances["geolocation"] = new GeoLocationMgr(p_mapctx, loc_layer);

			if (p_this.instances["basiccontrolsbox"] !== undefined) {

				p_this.instances["basiccontrolsbox"].addControl("gpspt", //togglable, p_drawface_func, p_endevent_func, p_mmove_func)
					false,
					function(p_ctrlsbox, p_ctx, p_left, p_top, p_width, p_height, p_basic_config, p_global_constants, p_toggle_flag) {

						let imgsrc;
						const imgh = new Image();
						imgh.decoding = "sync";

						imgsrc = p_basic_config.gpsposcontrol.symb.replace(/=%22black%22/g, `=%22${encodeURIComponent(p_ctrlsbox.strokeStyleFront)}%22`);

						imgh.src = imgsrc;
						imgh.decode()
						.then(() => {
							p_ctx.drawImage(imgh, p_left + ((p_global_constants.CONTROLS_STYLES.SIZE - p_basic_config.gpsposcontrol.symbwid) / 2), p_top);
						});
					},
					function(p_mapctx, p_evt, p_basic_config, p_global_constants) {
						p_this.instances["geolocation"].geolocPinpoint();
						const topcnv = p_mapctx.renderingsmgr.getTopCanvas();
						topcnv.style.cursor = "default";
						return true; // no toggle
					},
					function(p_mapctx, p_evt, p_basic_config, p_global_constants) {
						const topcnv = p_mapctx.renderingsmgr.getTopCanvas();
						topcnv.style.cursor = "pointer";
						ctrToolTip(p_mapctx, p_evt, p_mapctx.i18n.msg('GEOP', true));
					},
					GlobalConst.CONTROLS_STYLES.GAP
				);

				p_this.instances["basiccontrolsbox"].addControl("gpstrack", //p_drawface_func, p_endevent_func, p_mmove_func)
					true,
					function(p_ctrlsbox, p_ctx, p_left, p_top, p_width, p_height, p_basic_config, p_global_constants, p_control_status) {

						let imgsrc;
						const imgh = new Image();
						imgh.decoding = "sync";

						if (p_control_status.togglestatus) {
							imgsrc = p_basic_config.gpstrackcontrol.symb.replace(/=%22black%22/g, `=%22${encodeURIComponent(p_ctrlsbox.strokeStyleFrontOn)}%22`);
						} else {
							imgsrc = p_basic_config.gpstrackcontrol.symb.replace(/=%22black%22/g, `=%22${encodeURIComponent(p_ctrlsbox.strokeStyleFront)}%22`);
						}

						imgh.src = imgsrc;
						imgh.decode()
						.then(() => {
							p_ctx.drawImage(imgh, p_left + ((p_global_constants.CONTROLS_STYLES.SIZE - p_basic_config.gpstrackcontrol.symbwid) / 2), p_top);
						});
					},
					function(p_mapctx, p_evt, p_basic_config, p_global_constants) {
						const ret = p_this.instances["geolocation"].toggleGeolocWatch();
						const topcnv = p_mapctx.renderingsmgr.getTopCanvas();
						topcnv.style.cursor = "default";

						return ret;
					},
					function(p_mapctx, p_evt, p_basic_config, p_global_constants) {
						const topcnv = p_mapctx.renderingsmgr.getTopCanvas();
						topcnv.style.cursor = "pointer";
						ctrToolTip(p_mapctx, p_evt, p_mapctx.i18n.msg('GEOTRK', true));
					}
				);

			}

			p_this.instances["querying"] = new LocQuery(p_mapctx, p_this.messaging_ctrlr, basic_config["locquery"], basic_config["crs"], loc_layer);
			p_this.instances["querying"].setCustomizationUI(p_this, p_mapctx, GlobalConst, basic_config);
			console.info("[init RISCO] MapCustomizations, query box adapter launched");
		});

		const currentHeaders = new Headers();
		mapctx.setCurrentUser(currentHeaders.get('REMOTE_USER'));

		checkPoints(mapctx);

	

	</script>

</body> 
</html> 
